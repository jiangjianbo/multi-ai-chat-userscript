# 交互式主窗口原型开发提示词

## 1. 目标

创建一个名为 `mainwin.html` 的独立HTML文件，它将作为“多AI同步聊天”应用主窗口的一个高保真、可交互的前端原型。该原型应在视觉上具有代表性，并完整演示核心的UI/UX交互逻辑，无需任何后端或真实的消息通信。

## 2. 核心组件

1.  **主布局**: 页面采用三段式布局：
    *   位于顶部的 **标题栏**。
    *   位于中部的 **聊天区网格**，作为主要内容区域。
    *   位于底部的 **主输入栏**。

2.  **标题栏组件**:
    *   一个静态标题（例如，“多AI同步聊天”）。
    *   一个 **布局按钮组**，包含用于切换 1, 2, 3, 4, 6 个聊天区布局的按钮。
    *   一个 **控制按钮组**，包含“设置” (⚙️) 按钮和“新聊天” (➕) 按钮。

3.  **聊天区组件**:
    *   每个聊天区都是网格内的一个独立模块。
    *   **头部**: 包含该区域的专属控件。
    *   **内容显示区**: 一个可滚动的 `div`，用于展示对话消息。
    *   **输入区**: 一个 `textarea`，用于向特定AI输入消息。

4.  **主输入栏**:
    *   一个大的 `textarea`，用于输入需要广播到所有活动聊天区的消息。
    *   一个“发送”按钮。

## 3. 功能与交互需求

### 3.1. 布局管理

1.  **布局切换**: 点击布局按钮 (1-6) 应能动态地改变聊天区网格的CSS grid属性，以匹配所选的布局样式。
2.  **状态感知按钮**: 布局按钮必须能够感知当前状态。如果其代表的布局无法容纳当前所有打开的聊天区，则该按钮必须被禁用。例如，如果打开了3个聊天区，则“1”和“2”的布局按钮必须被禁用。
3.  **激活状态**: 当前生效的布局按钮需要有独特的视觉样式（例如，不同的背景色）以示区分。

### 3.2. 聊天区的生命周期

1.  **添加与移除**: “新聊天”按钮 (➕) 用于添加新区域；每个区域内的“关闭”按钮 (❌) 用于移除自身。
2.  **“未分配”状态**: 
    *   新创建的聊天区默认为“未分配”状态。
    *   此状态下，一个半透明的灰色遮罩层应**仅覆盖**聊天区的**主体**（内容和输入部分），其**头部必须保持可见且可交互**。
3.  **AI 分配**:
    *   “未分配”区域的头部有一个下拉菜单 (`<select>`)，用于选择AI。
    *   选择AI后，遮罩层消失，输入框变为可用，头部显示AI名称，完成分配。

### 3.3. 消息与输入

1.  **独立输入**: 
    *   在已分配的聊天区中，在其专属的 `textarea` 中按“回车”键（非Shift+Enter）发送消息，消息出现在其自身的内容区。
2.  **主输入框广播**:
    *   在底部的主输入栏中输入内容后，按“回车”键或点击“发送”按钮，应触发广播事件。
    *   该消息必须同时出现在**所有已分配**的聊天区的内容显示区内。
3.  **统一消息样式**: 所有由用户发送的消息，无论来源（主输入框或独立输入框），都应有相同的视觉样式（例如，绿色的、靠右对齐的气泡）。
4.  **模拟AI回复**:
    *   当任何用户消息出现在聊天区后，原型必须模拟一次来自对应AI的回复。
    *   此回复应在一个短暂且略带随机性的延迟（例如1-1.5秒）后出现。
    *   为模拟不同的AI引擎，每个聊天区的AI回复内容必须是独一无二的。可以使用一个预定义的回复数组，并根据聊天区的ID来选择不同的回复。
5.  **内容区自动滚动**: 当新消息（无论是用户的还是AI的）被添加到内容区时，该区域必须自动平滑滚动到底部，确保最新消息可见。

### 3.4. 交互式输入框

1.  **默认隐藏**: 在每个聊天区中，文本输入区域默认不占用固定的文档流空间。聊天内容区应延伸至面板最底部。
2.  **浮动触发器**: 一个小的、半透明的图标（例如“⬆️”）应浮动在内容区的右下角，作为输入框的触发器。
3.  **悬停/点击激活**: 
    *   当鼠标**悬停**在触发器或输入区域上时，完整的输入面板（带有背景和文本框）在底部出现。
    *   为防止遮挡最后一条消息，内容区的 `padding-bottom` 必须被动态增加，将消息列表向上推。
    *   如果用户**点击**了输入框（使其获得焦点），即使用户鼠标移开，输入面板也应保持可见。
4.  **自动隐藏**: 
    *   如果用户只是悬停而未点击，鼠标移开后输入面板应自动隐藏。
    *   如果用户点击后使其保持可见，那么当输入框**失去焦点**（`blur`事件）后，面板应自动隐藏。
    *   隐藏时，内容区的额外 `padding-bottom` 应被移除，使内容区恢复到底部。

## 4. Kimi 页面驱动原型 (kimi-driver.html)

### 4.1. 目标

创建一个名为 `kimi-driver.html` 的文件，用于模拟 Kimi 聊天页面的核心交互，并在此基础上实现一个问题索引（TOC）功能，同时验证特定页面元素的识别能力。

### 4.2. 页面结构与内容

1.  **基础HTML结构**: `kimi-driver.html` 的HTML结构应尽可能忠实于 `tests/kimi.html`，特别是新建会话、聊天消息区域、历史会话部分、会话标题、输入框和发送按钮。这包括保留相关的 `data-v-` 属性和类名，以模拟真实页面的复杂性。
2.  **历史会话列表**: 页面左侧的侧边栏应包含从 `tests/kimi.html` 复制的“历史会话” (`.history-part`) 及其列表内容。
3.  **会话标题**: 页面顶部应显示从 `tests/kimi.html` 复制的“未命名会话” (`.chat-header-content h2`) 标题。
4.  **提问输入框与发送按钮**: 页面底部应包含从 `tests/kimi.html` 复制的“尽管问...” (`.chat-input-editor`) 文本输入框和“发送” (`.send-button`) 按钮。

### 4.3. 问题索引 (TOC) 功能

1.  **索引内容**: TOC 应仅显示用户提问的序号（例如：1, 2, 3...），不包含提问的具体文本。
2.  **样式**: 每个索引数字应被圆形背景包裹，形成“串珠列表”效果。
3.  **位置**: TOC 应作为一个浮动元素，固定在视口（viewport）的左上角区域，并悬浮在主内容区之上。它不应占用独立的侧边栏空间，且不随主内容区的滚动而滚动。
4.  **交互**: 点击TOC中的数字，页面应平滑滚动到对应的用户提问位置。
5.  **激活状态**: 当前在视口中可见的用户提问对应的TOC数字应有高亮样式。

### 4.4. 驱动设计与日志

1.  **设计模式**: 整个功能应采用类似 `src/drivers.js` 的页面驱动设计模式，将逻辑封装在一个函数/类中（例如 `KimiPageDriverTOC`）。
2.  **元素识别与日志**: JavaScript 代码应在初始化时识别并打印以下元素的详细信息到控制台：
    *   “历史会话”部分及其列表内容（确认其存在和部分内容）。
    *   “未命名会话”标题（确认其文本内容）。
    *   主文本输入框（确认其存在和占位符文本）。
    *   “发送”按钮（确认其存在和文本内容）。